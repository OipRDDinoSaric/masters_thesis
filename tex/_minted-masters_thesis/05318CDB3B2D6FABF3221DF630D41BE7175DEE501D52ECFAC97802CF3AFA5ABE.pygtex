\begin{Verbatim}[commandchars=\\\{\}]
 \PYG{c+c1}{// Task to be created.}
 \PYG{k+kt}{void} \PYG{n+nf}{vTaskTimedCode}\PYG{p}{(} \PYG{k+kt}{void} \PYG{o}{*} \PYG{n}{pvParameters} \PYG{p}{)}
 \PYG{p}{\PYGZob{}}
     \PYG{k}{for}\PYG{p}{(} \PYG{p}{;;} \PYG{p}{)}
     \PYG{p}{\PYGZob{}}
         \PYG{c+c1}{// Task code goes here.}

         \PYG{c+c1}{// Reset the timer.}
         \PYG{n}{vTaskTimedReset}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{);}
     \PYG{p}{\PYGZcb{}}
 \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Function to be called if timer overflows.}
\PYG{k+kt}{void} \PYG{n+nf}{vTaskOverflowCallback} \PYG{p}{(} \PYG{n}{WorstTimeTimerHandle\PYGZus{}t} \PYG{n}{xTimer} \PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{// Timeout callback code.}

    \PYG{c+c1}{// Maybe task deletion is needed. Calling vTaskDelete automatically deletes}
    \PYG{c+c1}{// the timer too. Do NOT delete the timer directly. That will cause}
    \PYG{c+c1}{// undefined behavior when deleting the task.}
    \PYG{n}{vTaskDelete}\PYG{p}{(} \PYG{n}{xTimerGetTaskHandle}\PYG{p}{(} \PYG{n}{xTimer} \PYG{p}{)} \PYG{p}{);}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// Function to be called if timer overflows.}
\PYG{k+kt}{void} \PYG{n+nf}{vTaskOverrunCallback} \PYG{p}{(} \PYG{n}{WorstTimeTimerHandle\PYGZus{}t} \PYG{n}{xTimer} \PYG{p}{)}
\PYG{p}{\PYGZob{}}

    \PYG{c+c1}{// Timeout callback code.}

    \PYG{c+c1}{// Maybe task deletion is needed. Calling vTaskDelete automatically deletes}
    \PYG{c+c1}{// the timer too. Do NOT delete the timer directly. That will cause}
    \PYG{c+c1}{// undefined behavior when deleting the task.}
    \PYG{n}{vTaskDelete}\PYG{p}{(} \PYG{n}{xTimerGetTaskHandle}\PYG{p}{(} \PYG{n}{xTimer} \PYG{p}{)} \PYG{p}{);}
\PYG{p}{\PYGZcb{}}

 \PYG{c+c1}{// Function that creates a task.}
 \PYG{k+kt}{void} \PYG{n+nf}{vOtherFunction}\PYG{p}{(} \PYG{k+kt}{void} \PYG{p}{)}
 \PYG{p}{\PYGZob{}}
 \PYG{k}{static} \PYG{k+kt}{uint8\PYGZus{}t} \PYG{n}{ucParameterToPass}\PYG{p}{;}
 \PYG{n}{TaskHandle\PYGZus{}t} \PYG{n}{xHandle} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}

     \PYG{c+c1}{// Create the task, storing the handle.  Note that the passed parameter ucParameterToPass}
     \PYG{c+c1}{// must exist for the lifetime of the task, so in this case is declared static.  If it was just an}
     \PYG{c+c1}{// an automatic stack variable it might no longer exist, or at least have been corrupted, by the time}
     \PYG{c+c1}{// the new task attempts to access it.}
     \PYG{n}{xTaskCreate}\PYG{p}{(} \PYG{n}{vTaskCode}\PYG{p}{,}
                  \PYG{l+s}{\PYGZdq{}NAME\PYGZdq{}}\PYG{p}{,}
                  \PYG{n}{STACK\PYGZus{}SIZE}\PYG{p}{,}
                  \PYG{o}{\PYGZam{}}\PYG{n}{ucParameterToPass}\PYG{p}{,}
                  \PYG{n}{tskIDLE\PYGZus{}PRIORITY}\PYG{p}{,}
                  \PYG{o}{\PYGZam{}}\PYG{n}{xHandle}\PYG{p}{,}
                  \PYG{n}{pdMS\PYGZus{}TO\PYGZus{}TICKS}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{*} \PYG{l+m+mi}{1000}\PYG{p}{),}
                  \PYG{n}{vTaskOverrunCallback}\PYG{p}{,}
                  \PYG{n}{pdMS\PYGZus{}TO\PYGZus{}TICKS}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{l+m+mi}{1000}\PYG{p}{),}
                  \PYG{n}{vTaskOverflowCallback} \PYG{p}{);}
     \PYG{n}{configASSERT}\PYG{p}{(} \PYG{n}{xHandle} \PYG{p}{);}

     \PYG{c+c1}{// Use the handle to delete the task.}
     \PYG{k}{if}\PYG{p}{(} \PYG{n}{xHandle} \PYG{o}{!=} \PYG{n+nb}{NULL} \PYG{p}{)}
     \PYG{p}{\PYGZob{}}
         \PYG{n}{vTaskDelete}\PYG{p}{(} \PYG{n}{xHandle} \PYG{p}{);}
     \PYG{p}{\PYGZcb{}}
 \PYG{p}{\PYGZcb{}}
\end{Verbatim}
